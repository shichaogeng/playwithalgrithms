排序算法总结:
1. 插入排序平均时间复杂度O(N^2)
    当近乎有序时时间复杂度为O(N)

    额外空间 O(1)

    稳定性(排序前后的元素相对位置没有发生改变 可以用相同元素的位置来判断):稳定

========================================================
2. 归并排序平均时间复杂度为O(NlogN)

    需要额外空间 O(N)

    稳定性:稳定
========================================================
3. 快速排序平均时间复杂度为O(NlogN)
    当近乎有序时时间复杂度为O(N^2)---用随机法来解决
    快速排序有常数优势
    当有大量重复元素时,可以使用3路快速排序

    额外空间O(logN) 要占用栈空间递归

    稳定性:不稳定
========================================================
4. 堆排序平均时间复杂度为O(NlogN)

    额外空间O(1)

    稳定性:不稳定


反向索引
indexs[i] = j;
reverse[j] = i;

所以
indexs[reverse[i]] = i;
reverse[indexs[i]] = i;